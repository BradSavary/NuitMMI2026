# ğŸ® Copilot Instructions â€“ Jeu RPG 2D Ã  reconnaissance de gestes

## ğŸ¯ Objectif gÃ©nÃ©ral

Tu assistes au dÃ©veloppement d'un jeu 2D RPG en JavaScript utilisant **p5.js**, **p5play** et **ml5.js**.

Le jeu repose sur une progression linÃ©aire, un personnage qui avance automatiquement, et un systÃ¨me de sorts lancÃ©s par reconnaissance de gestes via la camÃ©ra.

### Ton rÃ´le est de :

Tu assistes au dÃ©veloppement dâ€™un jeu 2D RPG en JavaScript utilisant p5.js, p5play et ml5.js.

- GÃ©nÃ©rer du code clair, structurÃ© et commentÃ©

- Respecter strictement les mÃ©caniques dÃ©crites

- Proposer des solutions simples et robustes

- Toujours privilÃ©gier la lisibilitÃ© Ã  la complexitÃ© inutile



## ğŸ§© Technologies imposÃ©es

| Technologie | Usage |
|-------------|-------|

| **p5.js** | Rendu, boucle de jeu, camÃ©ra |

| **p5play** | Sprites, collisions, ennemis |

| **ml5.js** | Reconnaissance de gestes (HandPose ou modÃ¨le custom) |

| **JavaScript ES6** | Langage principal |

| **Next.js** | Framework (structure app/game/page.jsx) |



### âŒ Restrictions :

- Pas de framework externe supplÃ©mentaire

- Pas de backend

- Pas de logique serveur


## ğŸ—ºï¸ Structure gÃ©nÃ©rale du jeu

### Type de jeu

- Jeu 2D

- Vue side-scroller

- AvancÃ©e gauche â†’ droite

- Univers inspirÃ© du Japon / Nine Sols (niveau 1 uniquement)



### Progression

- Un niveau reprÃ©sente un **Ã©tage d'une tour**

- **Un seul niveau pour l'instant** (les Ã©tages suivants sont prÃ©vus pour le futur)


### ğŸ† SystÃ¨me de rÃ©compense "No Hit"

- Si le joueur termine un niveau **sans se faire toucher** pour la **premiÃ¨re fois** :

  - Il gagne **un cÅ“ur supplÃ©mentaire** â¤ï¸ ou **un nouveau sort** ğŸ”®

  - Cette rÃ©compense n'est obtenue qu'une seule fois


## ğŸ—ºï¸ Structure gÃ©nÃ©rale du jeu

### DÃ©placement

Le personnage :

- Avance **automatiquement** (dÃ©filement du dÃ©cor, personnage fixe Ã  l'Ã©cran)

- AccÃ©lÃ¨re quand il n'y a aucun ennemi

- Ralentit fortement quand un groupe ou un boss apparaÃ®t

- âš ï¸ **Le joueur ne contrÃ´le pas les dÃ©placements**

### SystÃ¨me de vie

- Barre de vie affichÃ©e avec **10 cÅ“urs** au dÃ©part

- PossibilitÃ© de gagner **1 cÅ“ur supplÃ©mentaire** via rÃ©compense "No Hit"

- DÃ©gÃ¢ts reÃ§us :

  - Ennemi normal â†’ **-1 PV**

  - Boss â†’ **-2 PV**

- **Effet visuel :** Flash rouge sur les bords de l'Ã©cran quand touchÃ©


## ğŸ”® SystÃ¨me de sorts 

1. Le joueur fait un **geste** avec la main devant la camÃ©ra (cercle avec la main droite, carrÃ©, la main au dessus de la tÃªte, etc...)

2. Le geste est reconnu via **ml5.js** et affichÃ© Ã  l'Ã©cran

3. Le joueur appuie sur **Espace**

4. Le sort correspondant est lancÃ©

## ğŸ¨ Comment l'affichage fonctionne
1. Le squelette de la main (lignes rouges/cyan selon la main) :

Le modÃ¨le HandPose dÃ©tecte 21 points sur chaque main (doigts, articulations, paume)
Ces points sont reliÃ©s par des lignes pour former le "squelette"
Main gauche = cyan (bleu-vert), Main droite = rouge
Ce squelette suit en temps rÃ©el vos mains
2. Le gros point jaune sur la paume :

C'est le point qui est suivi pour tracer les formes
Il se trouve exactement au centre de votre paume
C'est ce point qui laisse une trainÃ©e quand vous bougez
3. Les traits qui dessinent les formes :

Ã€ chaque instant, la position du point jaune est enregistrÃ©e
On garde les 80 derniÃ¨res positions en mÃ©moire
Ces positions sont reliÃ©es pour former une ligne continue = votre trajectoire
Quand vous retirez votre main de l'Ã©cran, les points s'effacent un par un progressivement
RÃ©sumÃ© : Le squelette montre oÃ¹ sont vos mains maintenant, et les traits montrent oÃ¹ elles sont passÃ©es dans les derniÃ¨res secondes. Le systÃ¨me compare ces traits aux formes attendues (cercle, ligne, zigzag...) pour voir si vous avez bien fait le geste !

### Types de sorts

PossibilitÃ© de lancer diffÃ©rents types de sorts :
- Zone ou cible unique
- Ã‰lÃ©ment : Feu / Glace / Terre / Ã‰lectrique / Neutre

Selon l'Ã©lÃ©ment du sort, les sorts doivent Ãªtre **inefficaces ou rÃ©duits** selon l'Ã©lÃ©ment de l'ennemi.

### FonctionnementLe personnage :

- SystÃ¨me simple :

  - Gestes distincts dessinÃ©s avec la main- Avance **automatiquement**

  - **Un geste = un sort**

  - Le geste doit Ãªtre validÃ© avec Espace


### âš ï¸ Ã€ dÃ©finir :

- Liste exacte des gestes Ã  reconnaÃ®tre (cercle, ligne, zigzag, spirale, etc.) ?

- Algorithme de reconnaissance : pattern matching sur la trainÃ©e ?

- Barre de vie affichÃ©e (dÃ©part : **10 cÅ“urs**)

- AvancÃ©e gauche â†’ droite

- Seuil de confiance pour valider un geste (80% ?)

- PossibilitÃ© de gagner des cÅ“urs supplÃ©mentaires via rÃ©compenses "No Hit"

---

## ğŸ‘¹ Ennemis et Boss

### Ennemis classiques

- Apparition progressive dans le niveau.

- **Types d'attaque :**

  - Corps Ã  corps

  - Distance

- **Ã‰lÃ©ment :** Feu / Glace / Terre / Ã‰lectrique / Neutre

- Patterns d'attaque fixes


### Boss

- Plus de PV

- Attaques plus complexes

- Infligent plus de dÃ©gÃ¢ts (-2 PV au lieu de -1)



## ğŸ§ª Ã‰cran d'entraÃ®nement (accessible via menu Ã‰chap)

- **Calibration de la camÃ©ra** (luminositÃ©, position)

- **Test des gestes** avec feedback en temps rÃ©el (est ce que le mouvement est dÃ©tectÃ© ou non)

- **Visualisation du mapping** geste â†’ sort

- **Mannequin d'entraÃ®nement** pour tester les dÃ©gÃ¢ts

- **Voir les points de la main** dans le mode debug et aussi dans le jeu normal (si activÃ© dans les paramÃ¨tres)

## ğŸ§± Architecture du code

### Structure de fichiers proposÃ©e

```

app/

â”œâ”€â”€ game/

â”‚   â”œâ”€â”€ page.jsx                    â†’ Point d'entrÃ©e Next.js

â”‚   â””â”€â”€ components/

â”‚       â”œâ”€â”€ GameCanvas.jsx          â†’ Canvas p5.js principal

â”‚       â”œâ”€â”€ TrainingScreen.jsx      â†’ Ã‰cran d'entraÃ®nement

â”‚       â””â”€â”€ UI/2. 

â”‚           â”œâ”€â”€ HealthBar.jsx       â†’ Barre de vie

â”‚           â”œâ”€â”€ UltimateBar.jsx     â†’ Jauge ultimate### Fonctionnement

â”‚           â”œâ”€â”€ SpellIndicator.jsx  â†’ Indicateur sort actuel

â”‚           â””â”€â”€ PauseMenu.jsx       â†’ Menu pause (Ã‰chap)

â”‚

â”œâ”€â”€ lib/  - Gestes distincts (ex : poing, main ouverte, V, etc.)

â”‚   â”œâ”€â”€ game/

â”‚   â”‚   â”œâ”€â”€ Player.js               â†’ Classe joueur 

â”‚   â”‚   â”œâ”€â”€ Enemy.js                â†’ Classe ennemis

â”‚   â”‚   â”œâ”€â”€ Boss.js                 â†’ Classe boss

â”‚   â”‚   â”œâ”€â”€ Spell.js                â†’ Classe sorts

â”‚   â”‚   â”œâ”€â”€ Level.js                â†’ Gestion du niveau

â”‚   â”‚   â””â”€â”€ GameManager.js          â†’ Ã‰tat global du jeu

â”‚   â”‚

â”‚   â”œâ”€â”€ gesture/

â”‚   â”‚   â”œâ”€â”€ HandPoseManager.js      â†’ Initialisation ml5.js

â”‚   â”‚   â”œâ”€â”€ GestureRecognizer.js    â†’ Reconnaissance patterns

â”‚   â”‚   â””â”€â”€ GestureDebugger.js      â†’ Affichage debug

â”‚   â”‚

â”‚   â””â”€â”€ utils/

â”‚       â”œâ”€â”€ config.js               â†’ Constantes du jeu

â”‚       â”œâ”€â”€ collision.js            â†’ DÃ©tection collisions

â”‚       â””â”€â”€ effects.js              â†’ Effets visuels

â”‚

â””â”€â”€ public/

    â”œâ”€â”€ sprites/                     â†’ Futurs assets SVG/GIF- Liste exacte des gestes Ã  reconnaÃ®tre ?

    â””â”€â”€ sounds/                      â†’ Futurs sons

```



### Principes architecturaux :

- **SÃ©paration des prÃ©occupations** : UI / Logique / Reconnaissance

- **Classes ES6** pour les entitÃ©s (Player, Enemy, Spell)---

- **Hooks React** pour la gestion d'Ã©tat Next.js

- **Config centralisÃ©e** pour les valeurs de gameplay---

- **Architecture modulaire** pour faciliter l'ajout de niveaux futurs



### Avantages de cette structure :

âœ… Facile d'ajouter de nouveaux sorts (un fichier Spell)  ## âš¡ UltimateğŸ¨ Comment l'affichage fonctionne

âœ… Facile d'ajouter de nouveaux niveaux (un fichier Level)  

âœ… Composants UI rÃ©utilisables 

âœ… SÃ©paration claire Next.js â†” p5.js  

âœ… Mode debug isolÃ©

----


## ğŸ¨ Graphismes & Assets



### Phase actuelle (dÃ©veloppement)

- Formes gÃ©omÃ©triques simples :

  - **Rectangles** pour les personnages

  - **Cercles** pour les sorts

  - **Couleurs** pour diffÃ©rencier les Ã©lÃ©ments
  
### Phase future (intÃ©gration assets)- Inflige de **trÃ¨s gros dÃ©gÃ¢ts**

- Support de : **SVG, GIF, WebP, PNG**

- Architecture permettant le remplacement facile des formes par des sprites- PossÃ¨de un **effet visuel spectaculaire**C'est le point qui est suivi pour tracer les formes

- Chargement des assets via `public/sprites/`


### Palette de couleurs provisoire :

- ğŸ”´ Feu = Rouge

- ğŸ”µ Glace = Bleu

- ğŸŸ¢ Terre = Vert

- ğŸŸ¡ Ã‰lectrique = Jaune

- âšª Neutre = Blanc/Gris



### âš ï¸ Ã€ dÃ©finir :- AOE (zone d'effet) ou ciblÃ© ?Ã€ chaque instant, la position du point jaune est enregistrÃ©e

- RÃ©solution cible du canvas (1920x1080, 1280x720 ?) ?
Par dÃ©faut : 1920x1080 mais essayer de rendre Ã§a responsive

## ğŸ¬ Interface & UX

### Menu principal (/game)

- â–¶ï¸ SÃ©lectionner niveau (pour l'instant 1 seul niveau)

- ğŸ¯ EntraÃ®nement (test et calibrage de la cam)

- âš™ï¸ Options (sensibilitÃ© gestes, volume, etc.)


### Pendant le jeu

- â¤ï¸ Barre de vie (haut gauche)

- âš¡ Jauge ultimate (haut droite)

- ğŸ”® Indicateur du sort actuel reconnu

- ğŸ’¥ Effets visuels (flash rouge si touchÃ©)



### Menu pause (Ã‰chap)

- â¸ï¸ Reprendre

- ğŸ¯ EntraÃ®nement

- âš™ï¸ Options

- ğŸšª Quitter le niveau (retour sur /game avec avertissement de non sauvegarde)


## ğŸµ SystÃ¨me Audio

Le jeu utilise un hook personnalisÃ© `useGameAudio` situÃ© dans `lib/hooks/useGameAudio.js` pour gÃ©rer tous les sons.

### Sons implÃ©mentÃ©s :

| Son | DÃ©clencheur | Type | Volume |
|-----|------------|------|--------|
| **main-song** | Menu principal (/game) | Boucle | 0.4 |
| **level-song** | Pendant le niveau | Boucle | 0.4 |
| **footsteps** | Tant que le MC est vivant | Boucle | 0.9 |
| **damage** | Quand le MC prend des dÃ©gÃ¢ts | One-shot | 0.6 |
| **fireball** | Sort de feu lancÃ© | One-shot | 0.5 |
| **icespear** | Sort de glace lancÃ© | One-shot | 0.5 |
| **lightning** | Sort de foudre lancÃ© | One-shot | 0.5 |
| **shield** | Sort de bouclier activÃ© | One-shot | 0.6 |

### Gestion automatique :

- Les sons en boucle se mettent en pause automatiquement quand le jeu est en pause
- Tous les sons s'arrÃªtent au dÃ©montage des composants
- Les sons one-shot peuvent se superposer (pour les sorts multiples)
- Fichiers audio stockÃ©s dans `/public/sounds/`


## ğŸ§  RÃ¨gles pour Copilot

1. Ne jamais inventer de mÃ©canique non dÃ©crite

2. Toujours expliquer briÃ¨vement le code gÃ©nÃ©rÃ© en commentaire

3. Proposer des alternatives simples

4. Si une fonctionnalitÃ© est future â†’ la simuler proprement